### 一

```c
var a = []
for (var i = 0; i < 10; i++) {
    a[i] = function () {
        console.log(i);
    }
}
a[6]()
```

打印结果：10

原因：在这里，i使用的是var进行定义的，而var是没有块级作用域的概念的，因此这里的i可以看做是全局变量，也就是说，数组a的成员里面的i，指向的都是同一个i。因此当我们在外部调用a[6]()时，所打印的i应该是全局变量i，而在最后一轮循环中由于i = 10，并不满足 i < 10的条件，所以 i的最后结果是10，最后的打印结果是 10。 

### 二

```c
var tmp = 123
if (true) {
    console.log(tmp);
    let tmp
}
```
结果：报错ReferenceError

原因：虽然使用var关键字声明了tmp全局变量，但是在 if 语句中，又使用let 关键字声明了一个局部变量tmp，导致局部变量tmp就绑定了这个作用域，形成了暂时性死区，所以在let声明tmp之前，使用tmp，就会报错。

### 三

```c
var arr = [12, 34, 32, 89, 4]
var min = Math.min(...arr)
console.log(min)
```

### 四


### 五

```c
var a = 10
var obj = {
    a: 20,
    fn () {
        setTimeout(() => {
            console.log(this.a); 
        })
    }
}
obj.fn()
```

打印结果：20

原因：obj.fn() 调用的是obj对象中的fn方法，那么根据谁调用this指向谁，此时fn方法中的this指向obj对象。而在定时器中，使用的是箭头函数的写法，而箭头函数是不改变this的指向的，所以定时器里面的this.a其实就是指的obj.a，因此打印出来的结果是 20。
如果将定时器中的回调函数改成普通函数的写法，那么此时定时器内部的this应该指向window，打印的应该是window.a，也就是全局中使用var声明的变量a，即打印出10。

### 六
   1、避免对象属性名相同产生的问题，为对象添加独一无二的属性名；
   2、模拟实现对象的私有成员。

### 七

浅拷贝就比如像引用类型，而深拷贝就比如值类型。

浅拷贝是指源对象与拷贝对象共用一份实体，仅仅是引用的变量不同（名称不同）。对其中任何一个对象的改动都会影响另外一个对象。

深拷贝是指源对象与拷贝对象互相独立，其中任何一个对象的改动都不会对另外一个对象造成影响。比较典型的就是Value（值）对象，如预定义类型Int32，Double，以及结构（struct），枚举（Enum）等。

### 八

TypeScript 是由微软开发的一种开源、跨平台的编程语言，是JavaScript 的超集，主要提供了类型系统和对 ES6 的支持，最终会被编译为JavaScript代码。编译出来的 JavaScript 可以运行在任何浏览器上。

详见 [TypeScript 语言规范与基本应用](https://blog.csdn.net/zimeng303/article/details/109596863)

### 九

**TypeScript的优势** 

**TypeScript 增加了代码的可读性和可维护性** 
a. 类型系统可以方便用户快速的使用类型定义过后的函数变量；
b. 在编译阶段发现错误，节省了运行之后出错的维护时间；
c. 增强了编辑器和 IDE 的功能，包括代码补全、接口提示、跳转到定义、重构等。

**TypeScript 非常包容** 
a. TypeScript 是 JavaScript 的超集，.js 文件可以直接重命名为 .ts 即可；
b. 可以根据变量的值等进行类型推论，可以定义从简单到复杂的几乎一切类型；
c. TypeScript 编译报错，不会影响生成 JavaScript 文件;
d. 兼容第三方库，即使第三方库不是用 TypeScript 写的，也可以编写单独的类型文件供 TypeScript 读取。

**TypeScript 拥有活跃的社区** 
a. 大部分第三方库都有提供给 TypeScript 的类型定义文件;
b. Google 开发的 Angular2 就是使用 TypeScript 编写的；
c. TypeScript 拥抱了 ES6 规范，也支持部分 ESNext 草案的规范。

**TypeScript的缺点** 

1）TypeScript 增加了接口（Interfaces）、泛型（Generics）、类（Classes）、枚举类型（Enums）等前端工程师不熟悉的概念，需要一定的学习成本；
2）项目初期，TypeScript 会增加一些开发成本，需要去编写一些类型的定义。但在后期维护时，会减少维护成本。
3）集成到构建流程需要一些工作量；
4）可能和一些库结合的不是很完美。

详见 [TypeScript 语言规范与基本应用](https://blog.csdn.net/zimeng303/article/details/109596863)

### 十

 **实现原理** 

1）核心思想：设置引用数，判断当前引用数是否为 0；
2）使用 引用计数器 进行计数；
3）引用关系改变时，引用计数器修改引用数字；
4）引用数字为 0 时，立即回收。

 **优点** 
1）可以即时回收垃圾对象；
2）当内存将要爆满时，会立即找到引用计数为0的对象空间进行释放，保证当前内存不会存在爆满的时候，因此可以最大限度减少程序暂停。

 **缺点** 
1）无法回收循环引用的对象；
2）由于需要时刻监控每个对象的引用数字是否需要修改，所以时间开销会增大。

详见 [内存管理、垃圾回收](https://blog.csdn.net/zimeng303/article/details/109667064)

### 十一

1）标记整理可以看做是标记清除的增强；
2）标记阶段的操作和标记清除一致；
3）清除阶段会先执行整理，移动对象位置。

详见 [内存管理、垃圾回收](https://blog.csdn.net/zimeng303/article/details/109667064)

### 十二

 **回收实现** 

1）回收过程采用复制算法 + 标记整理；
2）新生代内存区分为二个等大小空间；
3）使用空间为From，空闲空间为 To；
4）活动对象存储于 From 空间；
5）标记整理后将活动对象拷贝至 To；
6）From 与 To 交换空间完成释放。

 **回收细节说明** 

1）拷贝过程中可能出现晋升；
2）晋升就是将新生代对象移动至老年代；
3）一轮 GC 还存活的新生代需要晋升；
4）To 空间的使用率超过25%，进行限制。

详见 [内存管理、垃圾回收](https://blog.csdn.net/zimeng303/article/details/109667064)

### 十三、

 **工作原理** 

标记增量就是将当前一整段的垃圾回收操作拆分成多个小段，组合着去完成当前的整个回收，从而去替代原来的一口气做完的垃圾回收操作。

 **何时使用** 
回收老生代对象时，可能会由于需要回收的对象过多，导致页面出现很长时间的停顿，此时，利用增量标记算法，可以提高垃圾回收的效率，使用户有更好的体验。


详见 [内存管理、垃圾回收](https://blog.csdn.net/zimeng303/article/details/109667064)












